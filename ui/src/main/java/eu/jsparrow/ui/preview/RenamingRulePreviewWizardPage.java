package eu.jsparrow.ui.preview;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IPath;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.viewers.CheckStateChangedEvent;
import org.eclipse.jface.viewers.CheckboxTreeViewer;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerComparator;
import org.eclipse.jface.wizard.WizardPage;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.ltk.internal.ui.refactoring.TextEditChangePreviewViewer;
import org.eclipse.ltk.ui.refactoring.ChangePreviewViewerInput;
import org.eclipse.ltk.ui.refactoring.IChangePreviewViewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.SashForm;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.TextEdit;

import eu.jsparrow.core.rule.impl.PublicFieldsRenamingRule;
import eu.jsparrow.core.util.RefactoringUtil;
import eu.jsparrow.core.visitor.renaming.FieldMetaData;
import eu.jsparrow.ui.preview.model.RefactoringPreviewWizardModel;

/**
 * {@link WizardPage} containing view for preview of renaming changes. The
 * warning concerning restrictions is generated by a call to
 * {@link TextEditChangePreviewViewer}, which is an internal Eclipse class.
 * 
 * @author Andreja Sambolec
 * @since 2.3.0
 *
 */
@SuppressWarnings("restriction")
public class RenamingRulePreviewWizardPage extends WizardPage {

	private Map<FieldMetaData, Map<ICompilationUnit, DocumentChange>> changes;
	
	private CheckboxTreeViewer viewer;
	private IChangePreviewViewer currentPreviewViewer;
	
	private Composite previewComposite;

	private List<DocumentChangeWrapper> changesWrapperList;
	private DocumentChangeWrapper selectedDocWrapper;

	private List<FieldMetaData> uncheckedFields = new ArrayList<>();
	private List<FieldMetaData> recheckedFields = new ArrayList<>();
	private Map<IPath, Document> originalDocuments;

	public RenamingRulePreviewWizardPage(Map<FieldMetaData, Map<ICompilationUnit, DocumentChange>> changes,
			Map<ICompilationUnit, DocumentChange> changesPerRule, Map<IPath, Document> originalDocuments,
			PublicFieldsRenamingRule rule1, RefactoringPreviewWizardModel model1) {
		super(rule1.getRuleDescription()
			.getName());
		setTitle(rule1.getRuleDescription()
			.getName());
		setDescription(rule1.getRuleDescription()
			.getDescription());
		this.changes = changes;
		this.originalDocuments = originalDocuments;
		model1.addRule(rule1);
		changesPerRule.keySet()
			.stream()
			.forEach(x -> model1.addFileToRule(rule1, x.getHandleIdentifier()));

		convertChangesToDocumentChangeWrappers();

	}

	/**
	 * Creates {@link DocumentChangeWrapper} for each {@link DocumentChange}.
	 * First finds parent and then calls method to create children for that
	 * parent.
	 */
	private void convertChangesToDocumentChangeWrappers() {
		changesWrapperList = new ArrayList<>();
		for (Map.Entry<FieldMetaData, Map<ICompilationUnit, DocumentChange>> entry : changes.entrySet()) {
			FieldMetaData fieldData = entry.getKey();
			Map<ICompilationUnit, DocumentChange> changesForField = changes.get(fieldData);
			if (!changesForField.isEmpty()) {
				DocumentChange parent = null;
				ICompilationUnit parentICU = null;
				for (Map.Entry<ICompilationUnit, DocumentChange> dcEntry : changesForField.entrySet()) {
					ICompilationUnit iCompilationUnit = dcEntry.getKey();
					if ((fieldData.getDeclarationPath()).equals(iCompilationUnit.getPath())) {
						parent = changesForField.get(iCompilationUnit);
						parentICU = iCompilationUnit;
					}
				}
				if (null != parent) {
					createDocumentChangeWrapperChildren(fieldData, this.originalDocuments.get(parentICU.getPath()),
							changesForField, parent);
				}
			}
		}
		if (!changesWrapperList.isEmpty()) {
			this.selectedDocWrapper = changesWrapperList.get(0);
		}
	}

	/**
	 * Creates children for {@link DocumentChangeWrapper} parent.
	 * 
	 * @param fieldData
	 * @param changesForField
	 * @param parent
	 */
	private void createDocumentChangeWrapperChildren(FieldMetaData fieldData, Document originalDocument,
			Map<ICompilationUnit, DocumentChange> changesForField, DocumentChange parent) {
		DocumentChangeWrapper dcw = new DocumentChangeWrapper(parent, null, originalDocument, fieldData);
		for (Map.Entry<ICompilationUnit, DocumentChange> entry : changesForField.entrySet()) {
			ICompilationUnit iCompilationUnit = entry.getKey();
			if (!(fieldData.getDeclarationPath()).equals(iCompilationUnit.getPath())) {
				DocumentChange document = changesForField.get(iCompilationUnit);
				dcw.addChild(document, iCompilationUnit.getElementName(),
						this.originalDocuments.get(iCompilationUnit.getPath()));
			}
		}

		changesWrapperList.add(dcw);
	}

	@Override
	public void createControl(Composite parent) {
		Composite container = new Composite(parent, SWT.NONE);

		GridLayout layout = new GridLayout();

		// margin from TextEditChangePreviewViewer to Composite
		layout.marginHeight = 0;
		layout.marginWidth = 0;

		// without setting the layout, nothing displays
		container.setLayout(layout);

		setControl(container);

		SashForm sashForm = new SashForm(container, SWT.VERTICAL);

		createFileView(sashForm);
		createPreviewViewer(sashForm);

		/*
		 * sets height relation between children to be 1:3 when it has two
		 * children
		 */
		sashForm.setWeights(new int[] { 1, 3 });
	}

	/**
	 * Creates {@link CheckboxTreeViewer} which shows tree view of files with
	 * changes.
	 * 
	 * @param parent
	 *            component holding the viewer
	 */
	private void createFileView(SashForm parent) {
		viewer = new CheckboxTreeViewer(parent);
		viewer.getTree()
			.setLayoutData(new GridData(GridData.FILL_BOTH));
		viewer.setContentProvider(new ChangeElementContentProvider());
		viewer.setLabelProvider(new ChangeElementLabelProvider());
		viewer.setInput("root"); // pass a non-null that will be //$NON-NLS-1$
									// ignored

		/*
		 * When checkbox state changes, set same for parent, if element it self
		 * isn't parent, and all it's children
		 */
		viewer.addCheckStateListener(this::createCheckListener);

		viewer.addSelectionChangedListener(event -> {
			IStructuredSelection sel = (IStructuredSelection) event.getSelection();
			if (sel.size() == 1) {
				DocumentChangeWrapper newSelection = (DocumentChangeWrapper) sel.getFirstElement();
				if (!newSelection.equals(selectedDocWrapper)) {
					selectedDocWrapper = newSelection;
					populatePreviewViewer();
				}
			}
		});

		viewer.setComparator(new ViewerComparator() {
			@Override
			public int compare(Viewer viewer, Object e1, Object e2) {
				return ((DocumentChangeWrapper) e1).getOldIdentifier()
					.compareTo(((DocumentChangeWrapper) e2).getOldIdentifier());
			}
		});

		populateFileView();
	}

	private void createCheckListener(CheckStateChangedEvent event) {
		DocumentChangeWrapper selectedWrapper = (DocumentChangeWrapper) event.getElement();
		if (null == selectedWrapper.getParent()) {
			viewer.setSubtreeChecked(selectedWrapper, event.getChecked());
		} else {
			viewer.setSubtreeChecked(selectedWrapper.getParent(), event.getChecked());
		}
		
		 RenamingRulePreviewWizard wizard = (RenamingRulePreviewWizard) getWizard();
		
		if (event.getChecked()) {
			FieldMetaData recheckedFieldData = selectedWrapper.getFieldData();
			if (uncheckedFields.contains(recheckedFieldData)) {
				uncheckedFields.remove(recheckedFieldData);
			}
			
			if(!recheckedFields.contains(recheckedFieldData)) {
				recheckedFields.add(recheckedFieldData);
			}
			wizard.addMetaData(recheckedFieldData);
			
		} else {
			uncheckedFields.add(selectedWrapper.getFieldData());
			recheckedFields.remove(selectedWrapper.getFieldData());
			wizard.remove(selectedWrapper.getFieldData());
		}
		populatePreviewViewer();
	}

	/**
	 * Fills {@link CheckboxTreeViewer} component with data.
	 */
	private void populateFileView() {
		DocumentChangeWrapper[] changesArray = changesWrapperList.toArray(new DocumentChangeWrapper[] {});
		viewer.setInput(changesArray);
		Arrays.asList(changesArray)
			.stream()
			.forEach(change -> viewer.setSubtreeChecked(change, true));
	}

	/**
	 * Creates {@link TextEditChangePreviewViewer} component to display changes
	 * before and after applying the rule.
	 * 
	 * @param parent
	 *            component holding the viewer
	 */
	private void createPreviewViewer(SashForm parent) {

		previewComposite = new Composite(parent, SWT.NONE);
		// GridData works with GridLayout
		GridData gridData = new GridData(GridData.FILL_BOTH);
		parent.setLayoutData(gridData);
		previewComposite.setLayout(new GridLayout());
		previewComposite.setLayoutData(gridData);

		currentPreviewViewer = new TextEditChangePreviewViewer();
		currentPreviewViewer.createControl(previewComposite);

		currentPreviewViewer.getControl()
		.getParent()
		.layout();

		populatePreviewViewer();
	}

	/**
	 * Populates change viewer with data.
	 */
	public void populatePreviewViewer() {
		
		if (this.selectedDocWrapper != null) {
			disposeControl();

			currentPreviewViewer.createControl(previewComposite);
			currentPreviewViewer.getControl()
				.setLayoutData(new GridData(GridData.FILL_BOTH));

			ChangePreviewViewerInput viewerInput = TextEditChangePreviewViewer.createInput(getCurrentDocumentChange());
			currentPreviewViewer.setInput(viewerInput);
			
			currentPreviewViewer.getControl()
			.getParent()
			.layout();
		}
	}
	
	/**
	 * Used to populate preview viewer only if this page gets visible
	 */
	@Override
	public void setVisible(boolean visible) {
		if (visible) {
			populatePreviewViewer();
		} else {
			disposeControl();
		}
		super.setVisible(visible);
	}
	
	/**
	 * Used to dispose control every time preview viewer content changes or page
	 * gets invisible. New control is created when needed. This way conflicting
	 * handers are avoided because there is no multiple viewers which would
	 * register multiple handlers for same action.
	 */
	public void disposeControl() {
		if (null != currentPreviewViewer.getControl()) {
			currentPreviewViewer.getControl()
				.dispose();
		}
	}
	
	/**
	 * Gets the current DocumentChange if checkbox in front of file name is
	 * selected. Otherwise generates and returns new DocumentChange with empty
	 * text edit.
	 * 
	 * @return current or generated DocumentChange
	 */
	private DocumentChange getCurrentDocumentChange() {
		if (!viewer.getChecked(selectedDocWrapper)) {
			/*
			 * When compilation unit is unselected for rule that is shown,
			 * change preview viewer should show no change. For that generate
			 * document change is called with empty edit to create document
			 * change with text type java but with no changes.
			 */
			TextEdit edit = new MultiTextEdit();
			return RefactoringUtil.generateDocumentChange(selectedDocWrapper.getCompilationUnitName(),
					selectedDocWrapper.getOriginalDocument(), edit);
		} else {
			return selectedDocWrapper.getDocumentChange();
		}
	}
	
	public boolean isRecalculateNeeded() {
		return !uncheckedFields.isEmpty() || !recheckedFields.isEmpty();
	}

	public void populateViews(boolean forcePreviewViewerUpdate) {
		populateFileView();
		if (forcePreviewViewerUpdate) {
			populatePreviewViewer();
		}
		viewer.setSelection(new StructuredSelection(selectedDocWrapper));
	}
	
	
}

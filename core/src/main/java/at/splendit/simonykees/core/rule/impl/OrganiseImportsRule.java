package at.splendit.simonykees.core.rule.impl;

import org.apache.commons.lang3.JavaVersion;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.ISourceRange;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.search.TypeNameMatch;
import org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation;
import org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.IChooseImportQuery;
import org.eclipse.jface.text.Document;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.TextEdit;

import at.splendit.simonykees.core.rule.RefactoringRule;
import at.splendit.simonykees.core.util.SimonykeesUtil;
import at.splendit.simonykees.core.visitor.AbstractASTRewriteASTVisitor;
import at.splendit.simonykees.i18n.Messages;

/**
 * Organise imports in a Java class, the rule does not use an
 * {@link AbstractASTRewriteASTVisitor} so the abstract class itself can be
 * passed to the constructor. <br>
 * The warning concerning restrictions is generated by a call to
 * {@link OrganizeImportsOperation}, which is an internal Eclipse class
 * 
 * @author Hannes Schweighofer, Ludwig Werzowa
 * @since 0.9.2
 *
 */
@SuppressWarnings("restriction")
public class OrganiseImportsRule extends RefactoringRule<AbstractASTRewriteASTVisitor> {

	public OrganiseImportsRule(Class<AbstractASTRewriteASTVisitor> visitor) {
		super(visitor);
		this.name = Messages.OrganiseImportsRule_name;
		this.description = Messages.OrganiseImportsRule_description;
	}

	@Override
	protected JavaVersion provideRequiredJavaVersion() {
		return JavaVersion.JAVA_1_1;
	}

	@Override
	protected DocumentChange applyRuleImpl(ICompilationUnit workingCopy)
			throws ReflectiveOperationException, JavaModelException {

		// TODO monitor?

		// subMonitor.setWorkRemaining(workingCopies.size());

		// for (ICompilationUnit wc : workingCopies) {
		// subMonitor.subTask(getName() + ": " + wc.getElementName());
		// //$NON-NLS-1$
		// try {
		// applyOrganising(wc);
		// } catch (CoreException e) {
		// throw new JavaModelException(e);
		// }
		// if (subMonitor.isCanceled()) {
		// return;
		// } else {
		// subMonitor.worked(1);
		// }
		// }

		try {
			return applyOrganising(workingCopy);
		} catch (CoreException e) {
			throw new JavaModelException(e);
		}
	}

	private DocumentChange applyOrganising(ICompilationUnit workingCopy)
			throws OperationCanceledException, CoreException {

		final CompilationUnit astRoot = SimonykeesUtil.parse(workingCopy);
		final boolean hasAmbiguity[] = new boolean[] { false };
		IChooseImportQuery query = new IChooseImportQuery() {
			@Override
			public TypeNameMatch[] chooseImports(TypeNameMatch[][] openChoices, ISourceRange[] ranges) {
				hasAmbiguity[0] = true;
				return new TypeNameMatch[0];
			}
		};

		OrganizeImportsOperation importsOperation = new OrganizeImportsOperation(workingCopy, astRoot, false, true,
				true, query);
		TextEdit edit = importsOperation.createTextEdit(null);

		DocumentChange documentChange = null;

		if (!hasAmbiguity[0] && importsOperation.getParseError() == null && edit != null
				&& !(edit instanceof MultiTextEdit && edit.getChildrenSize() == 0)) {
			Document document = new Document(workingCopy.getSource());
			documentChange = SimonykeesUtil.generateDocumentChange(OrganiseImportsRule.class.getSimpleName(), document,
					edit.copy());

			workingCopy.applyTextEdit(edit, null);
			workingCopy.reconcile(ICompilationUnit.NO_AST, false, null, null);

		}

		return documentChange;

	}

}

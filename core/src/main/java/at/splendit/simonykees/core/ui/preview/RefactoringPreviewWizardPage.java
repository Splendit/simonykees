package at.splendit.simonykees.core.ui.preview;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.compare.CompareViewerSwitchingPane;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.viewers.CheckStateChangedEvent;
import org.eclipse.jface.viewers.CheckboxTableViewer;
import org.eclipse.jface.viewers.ColumnLabelProvider;
import org.eclipse.jface.viewers.ICheckStateListener;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.ltk.core.refactoring.TextChange;
import org.eclipse.ltk.internal.ui.refactoring.TextEditChangePreviewViewer;
import org.eclipse.ltk.ui.refactoring.IChangePreviewViewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.SashForm;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import at.splendit.simonykees.core.rule.RefactoringRule;
import at.splendit.simonykees.core.ui.AbstractWizardPage;
import at.splendit.simonykees.core.visitor.AbstractASTRewriteASTVisitor;

/**
 * The warning concerning restrictions is generated by a call to
 * {@link TextEditChangePreviewViewer}, which is an internal Eclipse class.
 * 
 * @author Ludwig Werzowa, Hannes Schweighofer, Andreja Sambolec
 * @since 0.9
 */
@SuppressWarnings("restriction")
public class RefactoringPreviewWizardPage extends AbstractWizardPage {

	private ICompilationUnit currentCompilationUnit;
	private IChangePreviewViewer currentPreviewViewer;
	private CheckboxTableViewer viewer;

	private Map<ICompilationUnit, DocumentChange> changesForRule;
	private RefactoringRule<? extends AbstractASTRewriteASTVisitor> rule;

	/*
	 * map that contains all names of working copies and working copies that
	 * were unselected for this page
	 */
	private Map<String, ICompilationUnit> unselected = new HashMap<>();

	/*
	 * map that contains working copies that are unselected in one iteration
	 * when this page is active
	 */
	private List<ICompilationUnit> unselectedChange = new ArrayList<>();

	private static final Logger logger = LoggerFactory.getLogger(RefactoringPreviewWizardPage.class);

	public RefactoringPreviewWizardPage(Map<ICompilationUnit, DocumentChange> changesForRule,
			RefactoringRule<? extends AbstractASTRewriteASTVisitor> rule) {
		super(rule.getName());
		setTitle(rule.getName());
		setDescription(rule.getDescription());

		this.changesForRule = changesForRule;
		this.rule = rule;

		this.currentCompilationUnit = changesForRule.keySet().stream().findFirst().orElse(null);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.
	 * widgets.Composite)
	 */
	@Override
	public void createControl(Composite parent) {
		Composite container = new Composite(parent, SWT.NONE);

		GridLayout layout = new GridLayout();

		// margin from TextEditChangePreviewViewer to Composite
		layout.marginHeight = 0;
		layout.marginWidth = 0;

		// without setting the layout, nothing displays
		container.setLayout(layout);

		setControl(container);

		SashForm sashForm = new SashForm(container, SWT.VERTICAL);

		createFileView(sashForm);
		createPreviewViewer(sashForm);

		/*
		 * sets height relation between children to be 1:3 when it has two
		 * children
		 */
		sashForm.setWeights(new int[] { 1, 3 });

	}

	private void createFileView(Composite parent) {
		viewer = CheckboxTableViewer.newCheckList(parent, SWT.MULTI);

		/*
		 * label provider that sets the text displayed in CompilationUnits table
		 * to show the name of the CompilationUnit
		 */
		viewer.setLabelProvider(new ColumnLabelProvider() {
			@Override
			public String getText(Object element) {
				ICompilationUnit compUnit = (ICompilationUnit) element;
				return String.format("%s - %s", getClassNameString(compUnit), getPathString(compUnit)); //$NON-NLS-1$
			}
		});

		viewer.addSelectionChangedListener(createSelectionChangedListener());
		viewer.addCheckStateListener(createCheckStateListener());

		populateFileView();

	}

	private void populateFileView() {
		// if redraw, remove all items before adding
		if (viewer.getTable().getItemCount() > 0) {
			viewer.getTable().removeAll();
		}
		// adding all elements in table and checking appropriately
		changesForRule.keySet().stream().forEach(entry -> {
			viewer.add(entry);
			viewer.setChecked(entry,
					(unselected.containsKey(entry.getElementName()) || unselectedChange.contains(entry)) ? false
							: true);
		});
	}

	/**
	 * Returns the class name of an {@link ICompilationUnit}, including ".java"
	 * 
	 * @param compilationUnit
	 * @return
	 */
	private String getClassNameString(ICompilationUnit compilationUnit) {
		return compilationUnit.getElementName();
	}

	/**
	 * Returns the path of an {@link ICompilationUnit} without leading slash
	 * (the same as in the Externalize Strings refactoring view).
	 * 
	 * @param compilationUnit
	 * @return
	 */
	private String getPathString(ICompilationUnit compilationUnit) {
		String temp = compilationUnit.getParent().getPath().toString();
		return temp.startsWith("/") ? temp.substring(1) : temp; //$NON-NLS-1$
	}

	private void createPreviewViewer(Composite parent) {

		// GridData works with GridLayout
		GridData gridData = new GridData(GridData.FILL_BOTH);
		parent.setLayoutData(gridData);

		currentPreviewViewer = new TextEditChangePreviewViewer();
		currentPreviewViewer.createControl(parent);

		populatePreviewViewer();

	}

	private ISelectionChangedListener createSelectionChangedListener() {
		return new ISelectionChangedListener() {
			@Override
			public void selectionChanged(SelectionChangedEvent event) {
				IStructuredSelection sel = (IStructuredSelection) event.getSelection();

				if (sel.size() == 1) {
					ICompilationUnit newSelection = (ICompilationUnit) sel.getFirstElement();
					if (!newSelection.equals(currentCompilationUnit)) {
						currentCompilationUnit = newSelection;
						populatePreviewViewer();
					}
				}
			}
		};
	}

	private ICheckStateListener createCheckStateListener() {
		return new ICheckStateListener() {

			public void checkStateChanged(CheckStateChangedEvent event) {

				ICompilationUnit newSelection = (ICompilationUnit) event.getElement();
				if (event.getChecked()) {
					/*
					 * remove from unselected and recalculate rules for this
					 * compilationUnit
					 */
					if (unselected.containsKey(newSelection.getElementName())) {
						unselected.remove(newSelection.getElementName());
					}
					if (unselectedChange.contains(newSelection)) {
						unselectedChange.remove(newSelection);
					}
					imediatelyUpdateForSelected(newSelection);
				} else {
					// add in list with unselected classes
					if (!unselected.containsKey(newSelection.getElementName())) {
						unselectedChange.add(newSelection);
					}
				}
			}
		};
	}

	private void imediatelyUpdateForSelected(ICompilationUnit newSelection) {
		((RefactoringPreviewWizard) getWizard()).imediatelyUpdateForSelected(newSelection, rule);
	}

	private void populatePreviewViewer() {
		currentPreviewViewer.setInput(TextEditChangePreviewViewer.createInput(getCurrentDocumentChange()));
		((CompareViewerSwitchingPane) currentPreviewViewer.getControl())
				.setTitleArgument(currentCompilationUnit.getElementName());
	}

	private DocumentChange getCurrentDocumentChange() {
		if (null == changesForRule.get(currentCompilationUnit)) {
			Document document;
			TextChange textChange = null;
			try {
				document = new Document(currentCompilationUnit.getSource());
				textChange = new DocumentChange(currentCompilationUnit.getElementName(), document);
			} catch (JavaModelException e) {
				logger.error(e.getMessage(), e);
			}
			return (DocumentChange) textChange;
		} else {
			return changesForRule.get(currentCompilationUnit);
		}
	}

	public List<ICompilationUnit> getUnselectedChange() {
		return unselectedChange;
	}

	/**
	 * When page is no more in focus, all changes are already stored and
	 * calculated, so unselected changes go to unselected map and cleans
	 * unselectedChanges list.
	 */
	public void applyUnselectedChange() {
		unselectedChange.stream().forEach(unit -> unselected.put(unit.getElementName(), unit));
		unselectedChange.clear();
	}

	public RefactoringRule<? extends AbstractASTRewriteASTVisitor> getRule() {
		return rule;
	}

	/**
	 * Updates changes for this page. IF there were changes in currently
	 * displayed working copy, it needs to be updated too.
	 * 
	 * @param changesForRule
	 */
	public void update(Map<ICompilationUnit, DocumentChange> changesForRule) {
		this.changesForRule = changesForRule;
		changesForRule.keySet().stream().forEach(unit -> {
			if (unit.getElementName().equals(currentCompilationUnit.getElementName())) {
				if (!unit.equals(currentCompilationUnit)) {
					currentCompilationUnit = unit;
				}
			}
			;
		});
	}

	/**
	 * Used to populate IChangePreviewViewer currentPreviewViewer and
	 * CheckboxTableViewer viewer every time page gets displayed. Sets the
	 * selection in file view part to match file whose changes are displayed in
	 * changes view.
	 */
	public void populateViews() {
		populateFileView();
		populatePreviewViewer();
		viewer.setSelection(new StructuredSelection(currentCompilationUnit));
	}
}

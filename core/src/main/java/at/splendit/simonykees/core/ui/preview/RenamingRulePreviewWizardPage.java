package at.splendit.simonykees.core.ui.preview;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.viewers.CheckboxTreeViewer;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerComparator;
import org.eclipse.jface.wizard.WizardPage;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.ltk.internal.ui.refactoring.TextEditChangePreviewViewer;
import org.eclipse.ltk.ui.refactoring.ChangePreviewViewerInput;
import org.eclipse.ltk.ui.refactoring.IChangePreviewViewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.SashForm;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.TextEdit;

import at.splendit.simonykees.core.exception.RefactoringException;
import at.splendit.simonykees.core.rule.impl.PublicFieldsRenamingRule;
import at.splendit.simonykees.core.ui.wizard.impl.WizardMessageDialog;
import at.splendit.simonykees.core.util.RefactoringUtil;
import at.splendit.simonykees.core.visitor.renaming.FieldMetadata;
import at.splendit.simonykees.i18n.ExceptionMessages;

/**
 * {@link WizardPage} containing view for preview of renaming changes. The
 * warning concerning restrictions is generated by a call to
 * {@link TextEditChangePreviewViewer}, which is an internal Eclipse class.
 * 
 * @author Andreja Sambolec
 * 
 * @since 2.3
 *
 */
@SuppressWarnings("restriction")
public class RenamingRulePreviewWizardPage extends WizardPage {

	private Map<FieldMetadata, Map<ICompilationUnit, DocumentChange>> changes;

	private CheckboxTreeViewer viewer;
	private IChangePreviewViewer currentPreviewViewer;

	private List<DocumentChangeWrapper> changesWrapperList;
	private DocumentChangeWrapper selectedDocWrapper;

	private List<FieldMetadata> uncheckedFields = new ArrayList<>();

	public RenamingRulePreviewWizardPage(Map<FieldMetadata, Map<ICompilationUnit, DocumentChange>> changes,
			PublicFieldsRenamingRule rule) {
		super(rule.getName());
		setTitle(rule.getName());
		setDescription(rule.getDescription());
		this.changes = changes;

		convertChangesToDocumentChangeWrappers();

	}

	/**
	 * Creates {@link DocumentChangeWrapper} for each {@link DocumentChange}.
	 * First finds parent and then calls method to create children for that
	 * parent.
	 */
	private void convertChangesToDocumentChangeWrappers() {
		changesWrapperList = new ArrayList<>();
		for (Map.Entry<FieldMetadata, Map<ICompilationUnit, DocumentChange>> entry : changes.entrySet()) {
			FieldMetadata fieldData = entry.getKey();
			Map<ICompilationUnit, DocumentChange> changesForField = changes.get(fieldData);
			if (!changesForField.isEmpty()) {
				DocumentChange parent = null;
				for (ICompilationUnit iCompilationUnit : changesForField.keySet()) {
					if (((ICompilationUnit) fieldData.getCompilationUnit().getJavaElement())
							.equals(iCompilationUnit.getPrimary())) {
						parent = changesForField.get(iCompilationUnit);
					}
				}
				if (null != parent) {
					createDocumentChangeWrapperChildren(fieldData, changesForField, parent);
				}
			}
		}
		if (!changesWrapperList.isEmpty()) {
			this.selectedDocWrapper = changesWrapperList.get(0);
		}
	}

	/**
	 * Creates children for {@link DocumentChangeWrapper} parent.
	 * 
	 * @param fieldData
	 * @param changesForField
	 * @param parent
	 */
	private void createDocumentChangeWrapperChildren(FieldMetadata fieldData,
			Map<ICompilationUnit, DocumentChange> changesForField, DocumentChange parent) {
		DocumentChangeWrapper dcw;
		try {
			dcw = new DocumentChangeWrapper(parent, null, fieldData);
			for (ICompilationUnit iCompilationUnit : changesForField.keySet()) {
				if (!((ICompilationUnit) fieldData.getCompilationUnit().getJavaElement())
						.equals(iCompilationUnit.getPrimary())) {
					DocumentChange document = changesForField.get(iCompilationUnit);
					dcw.addChild(document, iCompilationUnit.getElementName(), iCompilationUnit.getSource());
				}

			}

			changesWrapperList.add(dcw);
		} catch (JavaModelException e) {
			WizardMessageDialog.synchronizeWithUIShowInfo(
					new RefactoringException(ExceptionMessages.RefactoringPipeline_java_element_resolution_failed,
							ExceptionMessages.RefactoringPipeline_user_java_element_resolution_failed, e));
			return;
		}
	}

	@Override
	public void createControl(Composite parent) {
		Composite container = new Composite(parent, SWT.NONE);

		GridLayout layout = new GridLayout();

		// margin from TextEditChangePreviewViewer to Composite
		layout.marginHeight = 0;
		layout.marginWidth = 0;

		// without setting the layout, nothing displays
		container.setLayout(layout);

		setControl(container);

		SashForm sashForm = new SashForm(container, SWT.VERTICAL);

		createFileView(sashForm);
		createPreviewViewer(sashForm);

		/*
		 * sets height relation between children to be 1:3 when it has two
		 * children
		 */
		sashForm.setWeights(new int[] { 1, 3 });
	}

	/**
	 * Creates {@link CheckboxTreeViewer} which shows tree view of files with
	 * changes.
	 * 
	 * @param parent
	 *            component holding the viewer
	 */
	private void createFileView(SashForm parent) {
		viewer = new CheckboxTreeViewer(parent);
		viewer.getTree().setLayoutData(new GridData(GridData.FILL_BOTH));
		viewer.setContentProvider(new ChangeElementContentProvider());
		viewer.setLabelProvider(new ChangeElementLabelProvider());
		viewer.setInput("root"); // pass a non-null that will be //$NON-NLS-1$
									// ignored

		/*
		 * When checkbox state changes, set same for parent, if element it self
		 * isn't parent, and all it's children
		 */
		viewer.addCheckStateListener(event -> {
			if (null == ((DocumentChangeWrapper) event.getElement()).getParent()) {
				viewer.setSubtreeChecked(event.getElement(), event.getChecked());
			} else {
				viewer.setSubtreeChecked(((DocumentChangeWrapper) event.getElement()).getParent(), event.getChecked());
			}
			if (event.getChecked()) {
				if (uncheckedFields.contains(((DocumentChangeWrapper) event.getElement()).getFieldData())) {
					uncheckedFields.remove(((DocumentChangeWrapper) event.getElement()).getFieldData());
				}
			} else {
				uncheckedFields.add(((DocumentChangeWrapper) event.getElement()).getFieldData());
			}
			populatePreviewViewer();
		});

		viewer.addSelectionChangedListener(event -> {
			IStructuredSelection sel = (IStructuredSelection) event.getSelection();
			if (sel.size() == 1) {
				DocumentChangeWrapper newSelection = (DocumentChangeWrapper) sel.getFirstElement();
				if (!newSelection.equals(selectedDocWrapper)) {
					selectedDocWrapper = newSelection;
					populatePreviewViewer();
				}
			}
		});

		viewer.setComparator(new ViewerComparator() {
			@Override
			public int compare(Viewer viewer, Object e1, Object e2) {
				return ((DocumentChangeWrapper) e1).getOldIdentifier()
						.compareTo(((DocumentChangeWrapper) e2).getOldIdentifier());
			}
		});

		populateFileView();
	}

	/**
	 * Fills {@link CheckboxTreeViewer} component with data.
	 */
	private void populateFileView() {
		DocumentChangeWrapper[] changesArray = changesWrapperList.toArray(new DocumentChangeWrapper[] {});
		viewer.setInput(changesArray);
		Arrays.asList(changesArray).stream().forEach(change -> viewer.setSubtreeChecked(change, true));
	}

	/**
	 * Creates {@link TextEditChangePreviewViewer} component to display changes
	 * before and after applying the rule.
	 * 
	 * @param parent
	 *            component holding the viewer
	 */
	private void createPreviewViewer(SashForm parent) {

		// GridData works with GridLayout
		GridData gridData = new GridData(GridData.FILL_BOTH);
		parent.setLayoutData(gridData);

		currentPreviewViewer = new TextEditChangePreviewViewer();
		currentPreviewViewer.createControl(parent);

		populatePreviewViewer();
	}

	/**
	 * Populates change viewer with data.
	 */
	private void populatePreviewViewer() {
		if (this.selectedDocWrapper != null) {
			ChangePreviewViewerInput viewerInput = TextEditChangePreviewViewer.createInput(getCurrentDocumentChange());
			currentPreviewViewer.setInput(viewerInput);
		}
	}

	/**
	 * Gets the current DocumentChange if checkbox in front of file name is
	 * selected. Otherwise generates and returns new DocumentChange with empty
	 * text edit.
	 * 
	 * @return current or generated DocumentChange
	 */
	private DocumentChange getCurrentDocumentChange() {
		if (!viewer.getChecked(selectedDocWrapper)) {
			/*
			 * When compilation unit is unselected for rule that is shown,
			 * change preview viewer should show no change. For that generate
			 * document change is called with empty edit to create document
			 * change with text type java but with no changes.
			 */
			TextEdit edit = new MultiTextEdit();
			return RefactoringUtil.generateDocumentChange(selectedDocWrapper.getCompilationUnitName(),
					new Document(selectedDocWrapper.getCompilationUnitSource()), edit);
		} else {
			return selectedDocWrapper.getDocumentChange();
		}
	}

	/**
	 * Getter for list holding all unchecked Fields.
	 * 
	 * @return list with unchecked Fields
	 */
	public List<FieldMetadata> getUncheckedFields() {
		return uncheckedFields;
	}
}

package eu.jsparrow.core.rule.impl;

import org.apache.commons.lang3.JavaVersion;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.ISourceRange;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.search.TypeNameMatch;
import org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation;
import org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.IChooseImportQuery;
import org.eclipse.jface.text.Document;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.TextEdit;

import eu.jsparrow.core.rule.AbstractRefactoringRule;
import eu.jsparrow.core.util.RefactoringUtil;
import eu.jsparrow.core.visitor.AbstractASTRewriteASTVisitor;
import eu.jsparrow.i18n.Messages;

/**
 * Organise imports in a Java class, the rule does not use an
 * {@link AbstractASTRewriteASTVisitor} so the abstract class itself can be
 * passed to the constructor. <br>
 * The warning concerning restrictions is generated by a call to
 * {@link OrganizeImportsOperation}, which is an internal Eclipse class
 * 
 * @author Hannes Schweighofer, Ludwig Werzowa
 * @since 0.9.2
 *
 */
@SuppressWarnings("restriction")
public class OrganiseImportsRule extends AbstractRefactoringRule<AbstractASTRewriteASTVisitor> {

	public OrganiseImportsRule() {
		super();
		this.visitorClass = AbstractASTRewriteASTVisitor.class;
		this.name = Messages.OrganiseImportsRule_name;
		this.description = Messages.OrganiseImportsRule_description;
	}

	@Override
	protected JavaVersion provideRequiredJavaVersion() {
		return JavaVersion.JAVA_1_1;
	}

	@Override
	protected DocumentChange applyRuleImpl(ICompilationUnit workingCopy)
			throws ReflectiveOperationException, JavaModelException {

		try {
			return applyOrganising(workingCopy);
		} catch (CoreException e) {
			throw new JavaModelException(e);
		}
	}

	private DocumentChange applyOrganising(ICompilationUnit workingCopy)
			throws OperationCanceledException, CoreException {

		final CompilationUnit astRoot = RefactoringUtil.parse(workingCopy);
		final boolean hasAmbiguity[] = new boolean[] { false };
		IChooseImportQuery query = (TypeNameMatch[][] openChoices, ISourceRange[] ranges) -> {
			hasAmbiguity[0] = true;
			return new TypeNameMatch[0];
		};

		OrganizeImportsOperation importsOperation = new OrganizeImportsOperation(workingCopy, astRoot, false, true,
				true, query);
		TextEdit edit = importsOperation.createTextEdit(null);

		DocumentChange documentChange = null;

		if (!hasAmbiguity[0] && importsOperation.getParseError() == null && edit != null
				&& !(edit instanceof MultiTextEdit && edit.getChildrenSize() == 0)) {
			Document document = new Document(workingCopy.getSource());
			documentChange = RefactoringUtil.generateDocumentChange(OrganiseImportsRule.class.getSimpleName(), document,
					edit.copy());

			workingCopy.applyTextEdit(edit, null);
			workingCopy.reconcile(ICompilationUnit.NO_AST, false, null, null);

		}

		return documentChange;

	}

}

package eu.jsparrow.ui.preview;

import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.compare.CompareViewerSwitchingPane;
import org.eclipse.core.databinding.DataBindingContext;
import org.eclipse.core.databinding.UpdateValueStrategy;
import org.eclipse.core.databinding.beans.BeanProperties;
import org.eclipse.core.databinding.conversion.IConverter;
import org.eclipse.core.databinding.observable.value.IObservableValue;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.e4.core.contexts.ContextInjectionFactory;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.ui.dialogs.StatusInfo;
import org.eclipse.jdt.internal.ui.dialogs.StatusUtil;
import org.eclipse.jface.databinding.swt.WidgetProperties;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.viewers.CheckboxTableViewer;
import org.eclipse.jface.viewers.ColumnLabelProvider;
import org.eclipse.jface.viewers.ICheckStateListener;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerComparator;
import org.eclipse.jface.wizard.WizardPage;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.ltk.internal.ui.refactoring.TextEditChangePreviewViewer;
import org.eclipse.ltk.ui.refactoring.IChangePreviewViewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.CLabel;
import org.eclipse.swt.custom.SashForm;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Label;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.TextEdit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import eu.jsparrow.core.rule.impl.logger.StandardLoggerRule;
import eu.jsparrow.core.statistic.DurationFormatUtil;
import eu.jsparrow.i18n.Messages;
import eu.jsparrow.rules.common.RefactoringRule;
import eu.jsparrow.rules.common.statistics.FileChangeCount;
import eu.jsparrow.rules.common.statistics.RuleApplicationCount;
import eu.jsparrow.rules.common.util.RefactoringUtil;
import eu.jsparrow.ui.Activator;
import eu.jsparrow.ui.dialog.SimonykeesMessageDialog;
import eu.jsparrow.ui.preview.model.RefactoringPreviewWizardModel;
import eu.jsparrow.ui.preview.model.RefactoringPreviewWizardPageModel;
import eu.jsparrow.ui.preview.statistics.StatisticsArea;
import eu.jsparrow.ui.util.LicenseUtil;
import eu.jsparrow.ui.util.LicenseUtilService;
import eu.jsparrow.ui.util.PayPerUseCreditCalculator;
import eu.jsparrow.ui.util.ResourceHelper;

/**
 * The warning concerning restrictions is generated by a call to
 * {@link TextEditChangePreviewViewer}, which is an internal Eclipse class.
 * 
 * @author Ludwig Werzowa, Hannes Schweighofer, Andreja Sambolec, Hans-Jörg
 *         Schrödl, Matthias Webhofer
 * @since 0.9
 */
@SuppressWarnings("restriction")
public class RefactoringPreviewWizardPage extends WizardPage {

	private static final Logger logger = LoggerFactory.getLogger(RefactoringPreviewWizardPage.class);

	private CLabel techDebtLabel;
	private CLabel issuesFixedLabel;
	private CLabel requiredCredit;
	
	private StatisticsArea statisticsArea;

	private ICompilationUnit currentCompilationUnit;
	private IChangePreviewViewer currentPreviewViewer;
	private CheckboxTableViewer viewer;
	private Map<ICompilationUnit, DocumentChange> changesForRule;
	private RefactoringRule rule;

	private RefactoringPreviewWizardPageModel model;
	/*
	 * map that contains all names of working copies and working copies that
	 * were unselected for this page
	 */
	private Map<String, ICompilationUnit> unselected = new HashMap<>();
	private Composite previewContainer;
	/*
	 * map that contains working copies that are unselected in one iteration
	 * when this page is active
	 */
	private List<ICompilationUnit> unselectedChange = new ArrayList<>();
	protected IStatus fSelectionStatus;

	private RefactoringPreviewWizardModel wizardModel;

	private LicenseUtilService licenseUtil = LicenseUtil.get();

	public RefactoringPreviewWizardPage(Map<ICompilationUnit, DocumentChange> changesForRule, RefactoringRule rule,
			RefactoringPreviewWizardModel wizardModel, boolean enabled, StatisticsArea statisticsArea) {
		super(rule.getRuleDescription()
			.getName());
		CustomTextEditChangePreviewViewer.setEnableDiffView(enabled);
		ContextInjectionFactory.inject(this, Activator.getEclipseContext());

		setTitle(rule.getRuleDescription()
			.getName());
		setDescription(rule.getRuleDescription()
			.getDescription());

		this.wizardModel = wizardModel;
		this.model = new RefactoringPreviewWizardPageModel(rule, changesForRule);
		this.statisticsArea = statisticsArea;
		wizardModel.addRule(rule);
		changesForRule.keySet()
			.stream()
			.forEach(x -> wizardModel.addFileToRule(rule, x.getHandleIdentifier()));

		this.changesForRule = changesForRule;
		this.rule = rule;

		this.currentCompilationUnit = changesForRule.keySet()
			.stream()
			.findFirst()
			.orElse(null);

		fSelectionStatus = new StatusInfo();
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private void initializeDataBindings() {
		DataBindingContext bindingContext = new DataBindingContext();

		IConverter convertIssuesFixed = IConverter.create(Integer.class, String.class,
				x -> (String.format(Messages.SummaryWizardPageModel_IssuesFixed, (Integer) x)));
		IObservableValue issuesFixedLabelObserveValue = WidgetProperties.text()
			.observe(issuesFixedLabel);
		IObservableValue issuesFixedModelObserveValue = BeanProperties.value("issuesFixed") //$NON-NLS-1$
			.observe(model);
		bindingContext.bindValue(issuesFixedLabelObserveValue, issuesFixedModelObserveValue, null,
				UpdateValueStrategy.create(convertIssuesFixed));
		
		IConverter convertRequiredCredit = IConverter.create(Integer.class, String.class, x -> String.format("Used credit: %s", x));
		IObservableValue requiredCreditLabelObserveValue = WidgetProperties.text()
			.observe(requiredCredit);
		IObservableValue requiredCreditModelObserveValue = BeanProperties.value("requiredCredit") //$NON-NLS-1$
			.observe(model);
		bindingContext.bindValue(requiredCreditLabelObserveValue, requiredCreditModelObserveValue, null,
				UpdateValueStrategy.create(convertRequiredCredit));

		IConverter convertTimeSaved = IConverter.create(Duration.class, String.class, x -> String
			.format(Messages.DurationFormatUtil_TimeSaved, DurationFormatUtil.formatTimeSaved((Duration) x)));
		IObservableValue hoursSavedLabelObserveValue = WidgetProperties.text()
			.observe(techDebtLabel);
		IObservableValue hoursSavedModelObserveValue = BeanProperties.value("timeSaved") //$NON-NLS-1$
			.observe(model);
		bindingContext.bindValue(hoursSavedLabelObserveValue, hoursSavedModelObserveValue, null,
				UpdateValueStrategy.create(convertTimeSaved));

		this.statisticsArea.initializeDataBindings();

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.
	 * widgets.Composite)
	 */
	@Override
	public void createControl(Composite parent) {
		Composite container = new Composite(parent, SWT.NONE);

		GridLayout layout = new GridLayout(1, false);

		// margin from TextEditChangePreviewViewer to Composite
		layout.marginHeight = 0;
		layout.marginWidth = 0;

		// without setting the layout, nothing displays
		container.setLayout(layout);

		setControl(container);

		createStatisticsView(container);

		// Create the SashForm
		Composite sash = new Composite(container, SWT.NONE);
		sash.setLayout(new GridLayout());
		sash.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
		SashForm sashForm = new SashForm(sash, SWT.VERTICAL);

		createFileView(sashForm);
		createPreviewViewer(sashForm);

		if (!changesForRule.keySet()
			.isEmpty()) {
			this.currentCompilationUnit = (ICompilationUnit) viewer.getElementAt(0);
		}
		/*
		 * sets height relation between children to be 1:3 when it has two
		 * children
		 */
		sashForm.setWeights(1, 3);

		statisticsArea.createView(container);

		initializeDataBindings();
	}

	private void createStatisticsView(Composite rootComposite) {
		Composite composite = new Composite(rootComposite, SWT.NONE);
		GridLayout layout = new GridLayout(3, true);
		layout.marginHeight = 10;
		layout.marginWidth = 10;
		composite.setLayout(layout);
		composite.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));

		issuesFixedLabel = new CLabel(composite, SWT.NONE);
		issuesFixedLabel.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, true, true));
		Image inLoveImage = ResourceHelper.createImage("icons/fa-bolt.png"); //$NON-NLS-1$
		issuesFixedLabel.setImage(inLoveImage);
		
		requiredCredit = new CLabel(composite, SWT.NONE);
		requiredCredit.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, true));
		Image usedCreditImage = ResourceHelper.createImage("icons/fa-bolt.png"); //$NON-NLS-1$
		requiredCredit.setImage(usedCreditImage);

		techDebtLabel = new CLabel(composite, SWT.NONE);
		techDebtLabel.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, true, true));
		techDebtLabel.setImage(ResourceHelper.createImage("icons/fa-clock.png"));//$NON-NLS-1$

		Label label = new Label(rootComposite, SWT.SEPARATOR | SWT.HORIZONTAL);
		label.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
	}

	private void createFileView(Composite parent) {
		viewer = CheckboxTableViewer.newCheckList(parent, SWT.SINGLE);

		/*
		 * label provider that sets the text displayed in CompilationUnits table
		 * to show the name of the CompilationUnit
		 */
		viewer.setLabelProvider(new ColumnLabelProvider() {
			@Override
			public String getText(Object element) {
				ICompilationUnit compUnit = (ICompilationUnit) element;
				return String.format("%s - %s", getClassNameString(compUnit), getPathString(compUnit)); //$NON-NLS-1$
			}
		});

		viewer.setComparator(new ViewerComparator() {
			@Override
			public int compare(Viewer viewer, Object e1, Object e2) {
				ICompilationUnit compUnitFirst = (ICompilationUnit) e1;
				ICompilationUnit compUnitSecond = (ICompilationUnit) e2;
				return getClassNameString(compUnitFirst).compareTo(getClassNameString(compUnitSecond));
			}
		});

		viewer.addSelectionChangedListener(createSelectionChangedListener());
		viewer.addCheckStateListener(createCheckStateListener());

		populateFileView();

	}

	protected void populateFileView() {
		// if redraw, remove all items before adding
		if (viewer.getTable()
			.getItemCount() > 0) {
			viewer.getTable()
				.removeAll();
		}
		// adding all elements in table and checking appropriately
		changesForRule.keySet()
			.stream()
			.forEach(entry -> {
				viewer.add(entry);
				viewer.setChecked(entry,
						!(unselected.containsKey(entry.getElementName()) || unselectedChange.contains(entry)));
			});
	}

	/**
	 * Returns the class name of an {@link ICompilationUnit}, including ".java"
	 * 
	 * @param compilationUnit
	 * @return
	 */
	private String getClassNameString(ICompilationUnit compilationUnit) {
		return compilationUnit.getElementName();
	}

	/**
	 * Returns the path of an {@link ICompilationUnit} without leading slash
	 * (the same as in the Externalize Strings refactoring view).
	 * 
	 * @param compilationUnit
	 * @return
	 */
	private String getPathString(ICompilationUnit compilationUnit) {
		String temp = compilationUnit.getParent()
			.getPath()
			.toString();
		return StringUtils.startsWith(temp, "/") ? StringUtils.substring(temp, 1) : temp; //$NON-NLS-1$
	}

	private void createPreviewViewer(Composite parent) {

		// GridData works with GridLayout
		GridData gridData = new GridData(GridData.FILL_BOTH);
		parent.setLayoutData(gridData);

		previewContainer = new Composite(parent, SWT.NONE);
		previewContainer.setLayout(new GridLayout());
		previewContainer.setLayoutData(new GridData(GridData.FILL_BOTH));

		currentPreviewViewer = new CustomTextEditChangePreviewViewer();
	}

	private ISelectionChangedListener createSelectionChangedListener() {
		return event -> {
			IStructuredSelection sel = (IStructuredSelection) event.getSelection();

			if (sel.size() == 1) {
				ICompilationUnit newSelection = (ICompilationUnit) sel.getFirstElement();
				if (!newSelection.equals(currentCompilationUnit)) {
					currentCompilationUnit = newSelection;
					if (isCurrentPage()) {
						populatePreviewViewer();
					}
				}
			}
		};
	}

	private ICheckStateListener createCheckStateListener() {
		return event -> {
			ICompilationUnit newSelection = (ICompilationUnit) event.getElement();
			if (event.getChecked()) {
				/*
				 * remove from unselected and recalculate rules for this
				 * compilationUnit
				 */
				if (unselected.containsKey(newSelection.getElementName())) {
					unselected.remove(newSelection.getElementName());
				}
				if (unselectedChange.contains(newSelection)) {
					unselectedChange.remove(newSelection);
				}
				clearCounterForChangedFile(newSelection);
				wizardModel.addFileToRule(rule, newSelection.getHandleIdentifier());
				immediatelyUpdateForSelected(newSelection);
			} else {
				// add in list with unselected classes
				if (!unselected.containsKey(newSelection.getElementName())) {
					unselectedChange.add(newSelection);
				}
				clearCounterForChangedFile(newSelection);
				wizardModel.removeFileFromRule(rule, newSelection.getHandleIdentifier());
			}
			// This method simply counts checked items in the table. Not very
			// MVC, and should be replaced with a proper solution
			updateIssuesAndTimeForSelected();
		};
	}

	private void updateIssuesAndTimeForSelected() {
		int timesApplied = RuleApplicationCount.getFor(getRule())
			.getApplicationsForFiles(wizardModel.getFilesForRule(rule));
		model.setIssuesFixed(timesApplied);

		Duration timeSaved = getRule().getRuleDescription()
			.getRemediationCost()
			.multipliedBy(timesApplied);
		model.setTimeSaved(timeSaved);
		PayPerUseCreditCalculator calculator = new PayPerUseCreditCalculator();
		model.setRequiredCredit(calculator.measureWeight(rule));
		this.statisticsArea.updateForSelected();

	}

	/**
	 * Used to populate preview viewer only if this page gets visible
	 */
	@Override
	public void setVisible(boolean visible) {
		if (visible) {
			populatePreviewViewer();
			if (rule instanceof StandardLoggerRule) {
				doStatusUpdate();
			}
		} else {
			disposeControl();
		}
		super.setVisible(visible);
	}

	private void immediatelyUpdateForSelected(ICompilationUnit newSelection) {
		((RefactoringPreviewWizard) getWizard()).imediatelyUpdateForSelected(newSelection, rule);
	}

	private void populatePreviewViewer() {
		disposeControl();

		currentPreviewViewer.createControl(previewContainer);
		currentPreviewViewer.getControl()
			.setLayoutData(new GridData(GridData.FILL_BOTH));

		currentPreviewViewer.setInput(CustomTextEditChangePreviewViewer.createInput(getCurrentDocumentChange()));
		((CompareViewerSwitchingPane) currentPreviewViewer.getControl())
			.setTitleArgument(currentCompilationUnit.getElementName());

		currentPreviewViewer.getControl()
			.getParent()
			.layout();
	}

	private DocumentChange getCurrentDocumentChange() {
		if (null == changesForRule.get(currentCompilationUnit)) {
			DocumentChange documentChange = null;
			try {
				/*
				 * When compilation unit is unselected for rule that is shown,
				 * change preview viewer should show no change. For that
				 * generate document change is called with empty edit to create
				 * document change with text type java but with no changes.
				 */
				TextEdit edit = new MultiTextEdit();
				return RefactoringUtil.generateDocumentChange(currentCompilationUnit.getElementName(),
						new Document(currentCompilationUnit.getSource()), edit);
			} catch (JavaModelException e) {
				logger.error(e.getMessage(), e);
			}
			return documentChange;
		} else {
			return changesForRule.get(currentCompilationUnit);
		}
	}

	public List<ICompilationUnit> getUnselectedChange() {
		return unselectedChange;
	}

	/**
	 * When page is no more in focus, all changes are already stored and
	 * calculated, so unselected changes go to unselected map and cleans
	 * unselectedChanges list.
	 */
	public void applyUnselectedChange() {
		unselectedChange.stream()
			.forEach(unit -> unselected.put(unit.getElementName(), unit));
		unselectedChange.clear();
	}

	public RefactoringRule getRule() {
		return rule;
	}

	/**
	 * Updates changes for this page. IF there were changes in currently
	 * displayed working copy, it needs to be updated too.
	 * 
	 * @param changesForRule
	 */
	public void update(Map<ICompilationUnit, DocumentChange> changesForRule) {
		this.changesForRule = changesForRule;
		changesForRule.keySet()
			.stream()
			.filter(unit -> unit.getElementName()
				.equals(currentCompilationUnit.getElementName()) && !unit.equals(currentCompilationUnit))
			.forEach(unit -> currentCompilationUnit = unit);
	}

	/**
	 * Used to populate IChangePreviewViewer currentPreviewViewer and
	 * CheckboxTableViewer viewer every time page gets displayed. Sets the
	 * selection in file view part to match file whose changes are displayed in
	 * changes view. If forcePreviewViewerUpdate is set to true preview viewer
	 * is also populated. It is used only when this file is already visible
	 * (when previously unselected file gets selected again).
	 * 
	 * @param forcePreviewViewerUpdate
	 *            flag if preview viewer should be populated
	 */
	public void populateViews(boolean forcePreviewViewerUpdate) {
		populateFileView();
		if (forcePreviewViewerUpdate) {
			populatePreviewViewer();
		}
		viewer.setSelection(new StructuredSelection(currentCompilationUnit));
	}

	/**
	 * Open help dialog
	 */
	@Override
	public void performHelp() {
		SimonykeesMessageDialog.openDefaultHelpMessageDialog(getShell());
	}

	/**
	 * Used to dispose control every time preview viewer content changes or page
	 * gets invisible. New control is created when needed. This way conflicting
	 * handers are avoided because there is no multiple viewers which would
	 * register multiple handlers for same action.
	 */
	public void disposeControl() {
		if (null != currentPreviewViewer.getControl()) {
			currentPreviewViewer.getControl()
				.dispose();
		}
	}

	protected void doStatusUpdate() {
		if (licenseUtil.isFreeLicense()) {
			((StatusInfo) fSelectionStatus)
				.setWarning(Messages.RefactoringSummaryWizardPage_warn_disableFinishWhenFree);
		} else {
			fSelectionStatus = new StatusInfo();
		}

		/*
		 * the mode severe status will be displayed and the OK button
		 * enabled/disabled.
		 */
		updateStatus(fSelectionStatus);
	}

	/**
	 * Updates the status line and the OK button according to the given status
	 *
	 * @param status
	 *            status to apply
	 */
	protected void updateStatus(IStatus status) {
		StatusUtil.applyToStatusLine(this, status);
	}

	private void clearCounterForChangedFile(ICompilationUnit newSelection) {
		wizardModel.getChangedFilesPerRule()
			.keySet()
			.stream()
			.filter(changedFileRule -> wizardModel.getFilesForRule(changedFileRule)
				.contains(newSelection.getHandleIdentifier()))
			.map(changedFileRule -> RuleApplicationCount.getFor(changedFileRule)
				.getApplicationsForFile(newSelection.getHandleIdentifier()))
			.forEach(FileChangeCount::clear);
	}

}

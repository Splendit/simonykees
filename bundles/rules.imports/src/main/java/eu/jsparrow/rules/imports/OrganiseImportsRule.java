package eu.jsparrow.rules.imports;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.preferences.InstanceScope;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.ISourceRange;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.manipulation.CodeStyleConfiguration;
import org.eclipse.jdt.core.manipulation.JavaManipulation;
import org.eclipse.jdt.core.manipulation.OrganizeImportsOperation;
import org.eclipse.jdt.core.manipulation.OrganizeImportsOperation.IChooseImportQuery;
import org.eclipse.jdt.core.search.TypeNameMatch;
import org.eclipse.jface.text.Document;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.text.edits.TextEdit;
import org.osgi.service.prefs.BackingStoreException;
import org.osgi.service.prefs.Preferences;

import eu.jsparrow.rules.common.OrganiseImportsRuleBase;
import eu.jsparrow.rules.common.util.RefactoringUtil;
import eu.jsparrow.rules.common.visitor.AbstractASTRewriteASTVisitor;

/**
 * Organise imports in a Java class, the rule does not use an
 * {@link AbstractASTRewriteASTVisitor} so the abstract class itself can be
 * passed to the constructor. <br>
 * The warning concerning restrictions is generated by a call to
 * {@link OrganizeImportsOperation}, which is an internal Eclipse class
 * 
 * @author Hannes Schweighofer, Ludwig Werzowa, Matthias Webhofer
 * @since 0.9.2
 *
 */

public class OrganiseImportsRule extends OrganiseImportsRuleBase {

	@Override
	protected TextEdit createTextEdits(ICompilationUnit workingCopy, CompilationUnit astRoot,
			boolean[] hasAmbiguity) throws CoreException {
		setUpOrganizeImportsConstants();
		IChooseImportQuery query = (TypeNameMatch[][] openChoices, ISourceRange[] ranges) -> {
			hasAmbiguity[0] = true;
			return new TypeNameMatch[0];
		};

		OrganizeImportsOperation importsOperation = new OrganizeImportsOperation(workingCopy, astRoot, false, true,
				true, query);
		TextEdit edit = importsOperation.createTextEdit(null);
		if(hasAmbiguity[0] || importsOperation.getParseError() != null) {
			return null;
		}
		return edit;
	}

	@Override
	protected DocumentChange createDocumentChange(TextEdit edit, Document document) {
		DocumentChange documentChange;
		documentChange = RefactoringUtil.generateDocumentChange(OrganiseImportsRule.class.getSimpleName(), document,
				edit.copy());
		return documentChange;
	}
	
	
	/**
	 * If the JavaManipulation.PreferenceNodeId if not set. In Photon the
	 * previously internal Organize imports functionality was extracted, but not
	 * cleanly separated from jdt.ui, where constants remained.
	 * 
	 * This is a workaround to have the access to the default values that are
	 * set within Eclipse
	 * 
	 * TODO: find a better solution when adding the rule to the JMP
	 */
	protected void setUpOrganizeImportsConstants() {
		if (JavaManipulation.getPreferenceNodeId() == null) {
			Preferences preferences = InstanceScope.INSTANCE.getNode("eu.jsparrow.manipulation");
			preferences.put(CodeStyleConfiguration.ORGIMPORTS_IMPORTORDER, "java;javax;org;com");
			preferences.put(CodeStyleConfiguration.ORGIMPORTS_ONDEMANDTHRESHOLD, "99");
			preferences.put(CodeStyleConfiguration.ORGIMPORTS_STATIC_ONDEMANDTHRESHOLD, "99");
			try {
				// forces the application to save the preferences
				preferences.flush();
			} catch (BackingStoreException e) {
				e.printStackTrace();
			}
			JavaManipulation.setPreferenceNodeId("eu.jsparrow.manipulation");
		}
	}

}

package eu.jsparrow.core.visitor.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.IBinding;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.LambdaExpression;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.PrimitiveType.Code;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;

import eu.jsparrow.core.markers.common.UseArraysStreamEvent;
import eu.jsparrow.rules.common.util.ASTNodeUtil;
import eu.jsparrow.rules.common.util.ClassRelationUtil;
import eu.jsparrow.rules.common.visitor.AbstractAddImportASTVisitor;

/**
 * A visitor for transforming {@code Arrays.asList(T..values).stream()} into
 * either of the following:
 * 
 * <ul>
 * <li>Unboxed specialized stream ({@link IntStream}, {@link LongStream}, or
 * {@link DoubleStream}). For example, the following stream:
 * 
 * <pre>
 * {@code Arrays.asList(1, 2, 3).stream().forEach(val -> {})}
 * </pre>
 * 
 * is transformed to:
 * 
 * <pre>
 * {@code Arrays.stream(new int[]{1, 2, 3}).forEach(val -> {})}
 * </pre>
 * 
 * Thus, avoiding an unnecessary boxing of the elements of the stream.</li>
 * 
 * <li>Stream generated by the short hand method {@link Stream#of(Object...)}.
 * For example, the following code:
 * 
 * <pre>
 * {@code Arrays.asList("1", "2", "3").stream().forEach(val -> {})}
 * </pre>
 * 
 * is transformed to:
 * 
 * <pre>
 * {@code Stream.of("1", "2", "3").forEach(val -> {})}
 * </pre>
 * 
 * </li>
 * </ul>
 * 
 * @since 3.18.0
 * 
 *        Implemented in SIM-1747
 */
public class UseArraysStreamASTVisitor extends AbstractAddImportASTVisitor implements UseArraysStreamEvent {

	private static final String STREAM_QUALIFIED_NAME = java.util.stream.Stream.class.getName();
	private static final String ARRAYS_QUALIFIED_NAME = java.util.Arrays.class.getName();
	@SuppressWarnings("nls")
	private static final List<String> BLOCKED_LIST = Collections.unmodifiableList(Arrays.asList(
			"mapToInt",
			"mapToLong",
			"mapToDouble",
			"flatMap",
			"flatMapToInt",
			"flatMapToLong",
			"flatMapToDouble",
			"toArray",
			"sorted",
			"toArray",
			"reduce",
			"collect",
			"findFirst",
			"findAny",
			"iterate",
			"generate",
			"concat"));

	@Override
	public boolean visit(CompilationUnit compilationUnit) {
		boolean continueVisiting = super.visit(compilationUnit);
		if (continueVisiting) {
			verifyImport(compilationUnit, ARRAYS_QUALIFIED_NAME);
			verifyImport(compilationUnit, STREAM_QUALIFIED_NAME);
		}
		return continueVisiting;
	}

	@Override
	public boolean visit(MethodInvocation methodInvocation) {
		boolean hasRightType = isMethodDeclaredOnType(methodInvocation, "asList", ARRAYS_QUALIFIED_NAME); //$NON-NLS-1$
		if (!hasRightType) {
			return true;
		}
		StructuralPropertyDescriptor propertyDescriptor = methodInvocation.getLocationInParent();
		if (propertyDescriptor != MethodInvocation.EXPRESSION_PROPERTY) {
			return true;
		}
		MethodInvocation parent = (MethodInvocation) methodInvocation.getParent();
		if (!isMethodDeclaredOnType(parent, "stream", java.util.Collection.class.getName())) { //$NON-NLS-1$
			return false;
		}

		List<Expression> arguments = ASTNodeUtil.convertToTypedList(methodInvocation.arguments(), Expression.class);
		if (arguments.isEmpty()) {
			return true;
		}
		Expression argument = arguments.get(0);
		ITypeBinding argumentTypeBinding = argument.resolveTypeBinding();
		if (!argumentTypeBinding.isArray() && hasSpecializedStream(argumentTypeBinding)) {
			List<MethodInvocation> methodChain = extractStreamChain(parent);
			if (!isCompatibleWithSpecializedStream(methodChain, parent)) {
				return true;
			}
			Expression experssion = methodInvocation.getExpression();
			replaceWithArraysStream(parent, arguments, argumentTypeBinding, experssion);
			addMarkerEvent(parent, arguments, argumentTypeBinding.getName(), experssion);
			onRewrite();
			return true;
		} else {
			replaceWithStreamOf(parent, arguments);
			addMarkerEvent(parent, arguments);
			onRewrite();
			return true;
		}
	}

	private void replaceWithStreamOf(MethodInvocation parent, List<Expression> arguments) {
		AST ast = parent.getAST();
		Expression expression = addImport(STREAM_QUALIFIED_NAME, parent);
		ListRewrite listRewrite = astRewrite.getListRewrite(parent, MethodInvocation.ARGUMENTS_PROPERTY);
		arguments.forEach(arg -> listRewrite.insertLast(astRewrite.createMoveTarget(arg), null));

		astRewrite.replace(parent.getExpression(), expression, null);
		astRewrite.replace(parent.getName(), ast.newSimpleName("of"), null); //$NON-NLS-1$
	}

	private void replaceWithArraysStream(MethodInvocation stream, List<Expression> arguments,
			ITypeBinding argumentTypeBinding, Expression experession) {
		AST ast = stream.getAST();
		ArrayCreation arrayCreation = ast.newArrayCreation();
		Code primitiveType = PrimitiveType.toCode(argumentTypeBinding.getName());
		ArrayType arrayType = ast.newArrayType(ast.newPrimitiveType(primitiveType));
		arrayCreation.setType(arrayType);
		ArrayInitializer initializer = ast.newArrayInitializer();
		@SuppressWarnings("unchecked")
		List<Expression> initializerExpressions = initializer.expressions();
		arguments.stream()
			.map(arg -> (Expression) astRewrite.createMoveTarget(arg))
			.forEach(initializerExpressions::add);
		arrayCreation.setInitializer(initializer);

		ListRewrite listRewrite = astRewrite.getListRewrite(stream, MethodInvocation.ARGUMENTS_PROPERTY);
		listRewrite.insertFirst(arrayCreation, null);

		if (experession != null) {
			astRewrite.replace(stream.getExpression(), astRewrite.createCopyTarget(experession), null);
		} else {
			Name arraysTypeName = addImport(ARRAYS_QUALIFIED_NAME, stream);
			astRewrite.replace(stream.getExpression(), arraysTypeName, null);
		}
	}

	private boolean isCompatibleWithSpecializedStream(List<MethodInvocation> methodChain, MethodInvocation stream) {
		ITypeBinding typeBinding = stream.resolveTypeBinding();
		boolean compatible = true;

		for (MethodInvocation method : methodChain) {
			boolean compatibleWithUnboxed = isCompatibleWithUnboxedParameter(method);
			if (!compatibleWithUnboxed) {
				compatible = false;
			}
			ITypeBinding newStreamType = method.resolveTypeBinding();
			if (!"void".equals(newStreamType.getName()) //$NON-NLS-1$
					&& !ClassRelationUtil.compareITypeBinding(typeBinding, newStreamType)) {
				compatible = false;
			}

			if (!compatible) {
				break;
			}
		}
		return compatible;
	}

	private boolean isCompatibleWithUnboxedParameter(MethodInvocation method) {
		SimpleName name = method.getName();
		if (BLOCKED_LIST.contains(name.getIdentifier())) {
			return false;
		}

		LambdaExpression lambdaExpressionAsOnlyArgument = ASTNodeUtil
			.findSingletonListElement(method.arguments(), LambdaExpression.class)
			.orElse(null);
		if (lambdaExpressionAsOnlyArgument == null) {
			return false;
		}

		ASTNode lambdaBody = lambdaExpressionAsOnlyArgument.getBody();

		VariableDeclarationFragment parameter = ASTNodeUtil
			.findSingletonListElement(lambdaExpressionAsOnlyArgument.parameters(), VariableDeclarationFragment.class)
			.orElse(null);
		if (parameter == null) {
			return false;
		}

		UnboxCompatibilityVisitor visitor = new UnboxCompatibilityVisitor(parameter.getName());
		lambdaBody.accept(visitor);
		return !visitor.isIncompatible();
	}

	private List<MethodInvocation> extractStreamChain(MethodInvocation methodInvocation) {
		List<MethodInvocation> chain = new ArrayList<>();

		StructuralPropertyDescriptor locationInParent = methodInvocation.getLocationInParent();
		if (locationInParent == MethodInvocation.EXPRESSION_PROPERTY) {
			MethodInvocation parent = (MethodInvocation) methodInvocation.getParent();
			IMethodBinding parentMethodBinding = parent.resolveMethodBinding();
			if (parentMethodBinding != null) {
				ITypeBinding declaringClass = parentMethodBinding.getDeclaringClass();
				boolean isStreamMethod = ClassRelationUtil.isContentOfType(declaringClass, STREAM_QUALIFIED_NAME);
				if (isStreamMethod) {
					chain.add(parent);
					chain.addAll(extractStreamChain(parent));
				}
			}
		}
		return chain;
	}

	private boolean hasSpecializedStream(ITypeBinding argumentTypeBinding) {
		String typeName = argumentTypeBinding.getName();
		switch (typeName) {
		case "int": //$NON-NLS-1$
		case "double": //$NON-NLS-1$
		case "long": //$NON-NLS-1$
			return true;
		default:
			return false;
		}
	}

	private boolean isMethodDeclaredOnType(MethodInvocation methodInvocation, String expectedName,
			String expectedType) {
		SimpleName name = methodInvocation.getName();
		if (!expectedName.equals(name.getIdentifier())) {
			return false;
		}
		IMethodBinding methodBinding = methodInvocation.resolveMethodBinding();
		if (methodBinding == null) {
			return false;
		}
		ITypeBinding declaringClass = methodBinding.getDeclaringClass();
		return ClassRelationUtil.isContentOfType(declaringClass, expectedType);
	}

	class UnboxCompatibilityVisitor extends ASTVisitor {

		private SimpleName parameter;
		private boolean incompatible;

		public UnboxCompatibilityVisitor(SimpleName parameter) {
			this.parameter = parameter;
		}

		@Override
		public boolean visit(SimpleName simpleName) {
			String identifier = simpleName.getIdentifier();
			if (!identifier.equals(parameter.getIdentifier())) {
				return false;
			}
			IBinding binding = simpleName.resolveBinding();
			if (binding.getKind() != IBinding.VARIABLE) {
				return false;
			}
			List<StructuralPropertyDescriptor> properties = findStructuralProperties(simpleName);
			incompatible = properties.stream()
				.anyMatch(property -> property == MethodInvocation.EXPRESSION_PROPERTY);
			return false;
		}

		private List<StructuralPropertyDescriptor> findStructuralProperties(ASTNode simpleName) {
			List<StructuralPropertyDescriptor> properties = new ArrayList<>();
			properties.add(simpleName.getLocationInParent());
			ASTNode parent = simpleName.getParent();

			if (parent != null
					&& parent.getNodeType() != ASTNode.LAMBDA_EXPRESSION
					&& !(parent instanceof Statement)) {
				properties.addAll(findStructuralProperties(parent));
			}
			return properties;
		}

		public boolean isIncompatible() {
			return incompatible;
		}
	}
}

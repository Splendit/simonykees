package eu.jsparrow.standalone;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.maven.shared.invoker.MavenInvocationException;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IProjectDescription;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.osgi.util.NLS;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import eu.jsparrow.i18n.Messages;

/**
 * Class that contains all configuration needed to run headless version of
 * jSparrow Eclipse plugin.
 * 
 * @author Andreja Sambolec, Matthias Webhofer
 * @since 2.1.1
 */
public class StandaloneConfig {

	private static final Logger logger = LoggerFactory.getLogger(StandaloneConfig.class);

	private static final String ECLIPSE_MAVEN_NAME = "eclipse"; //$NON-NLS-1$
	private static final String ECLIPSE_CLEAN_GOAL = "clean"; //$NON-NLS-1$

	private static final String PROJECT_FILE_NAME = ".project"; //$NON-NLS-1$
	private static final String CLASSPATH_FILE_NAME = ".classpath"; //$NON-NLS-1$
	private static final String SETTINGS_DIRECTORY_NAME = ".settings"; //$NON-NLS-1$
	private static final String TEMP_FILE_EXTENSION = ".tmp"; //$NON-NLS-1$

	private String path;
	private String compilerCompliance;
	private String mavenHome;

	private boolean descriptionGenerated = false;
	private boolean cleanUpAlreadyDone = false;
	private boolean existingProjectFileMoved = false;
	private boolean existingClasspathFileMoved = false;
	private boolean existingSettingsDirectoryMoved = false;

	private IJavaProject javaProject = null;

	private List<ICompilationUnit> compUnits = new ArrayList<>();

	private IClasspathEntry[] oldEntries;

	private MavenInvoker mavenInovker;

	/**
	 * Constructor that calls setting up of the project and collecting the
	 * compilation units.
	 * 
	 * @param path
	 *            to the folder of the project
	 * @param compilerCompliance
	 *            java version of the project (i.e. "1.8" or "9")
	 * @param mavenHome
	 *            path to the maven home directory
	 * @throws CoreException
	 * @throws MavenInvocationException
	 * @throws IOException
	 */
	public StandaloneConfig(String path, String compilerCompliance, String mavenHome)
			throws CoreException, MavenInvocationException, IOException {
		this(path, compilerCompliance, mavenHome, false);
	}

	public StandaloneConfig(String path, String compilerCompliance, String mavenHome, boolean testMode)
			throws CoreException, MavenInvocationException, IOException {
		this.path = path;
		this.compilerCompliance = compilerCompliance;
		this.mavenHome = mavenHome;

		this.mavenInovker = getMavenInvoker();

		if (!testMode) {
			setUp();
		}
	}

	/**
	 * Create workspace and load project into it. If a .project file does not
	 * exist, one is generated by using the eclipse maven plugin.
	 * 
	 * @throws CoreException
	 * @throws MavenInvocationException
	 * @throws IOException
	 */
	public void setUp() throws CoreException, MavenInvocationException, IOException {
		IProjectDescription projectDescription = getProjectDescription();
		IProject project = this.initProject(projectDescription);
		this.initJavaProject(project);
		List<IClasspathEntry> mavenClasspathEntries = this.collectMavenDependenciesAsClasspathEntries();
		this.addToClasspath(mavenClasspathEntries);
		compUnits = getCompilationUnits();
	}

	/**
	 * if a project description already exists, it is already an eclipse project
	 * and the project description gets loaded. otherwise an Eclipse project is
	 * temporarily created by using the maven eclipse plugin.
	 * 
	 * @return a project description for an eclipse project
	 * @throws CoreException
	 * @throws MavenInvocationException
	 * @throws IOException
	 */
	IProjectDescription getProjectDescription() throws CoreException, MavenInvocationException, IOException {
		IWorkspace workspace = getWorkspace();

		IProjectDescription description = null;

		boolean invokeMavenEclipsePlugin = prepareEclipseMavenPlugin();

		if (invokeMavenEclipsePlugin) {
			logger.debug(Messages.StandaloneConfig_executeMavenEclipseEclipseGoal);
			mavenInovker.invoke(ECLIPSE_MAVEN_NAME, ECLIPSE_MAVEN_NAME, null);
			descriptionGenerated = true;
		}

		logger.debug(Messages.StandaloneConfig_UseExistingProjectDescription);
		description = workspace.loadProjectDescription(new Path(getProjectDescriptionFile().getAbsolutePath()));

		return description;
	}

	/**
	 * this method checks if the eclipse:eclipse maven plugin should be executed
	 * to convert the current project to an eclipse project and prepares it
	 * accordingly by renaming any existing .project and .classpath files and
	 * the .settings directory temporarily.
	 * 
	 * @return true, if the elcipse:eclipse maven plugin should be executed,
	 *         false otherwise
	 * @throws IOException
	 */
	protected boolean prepareEclipseMavenPlugin() throws IOException {
		File projectDescription = getProjectDescriptionFile();
		File classpathFile = getClasspathFileFile();
		File settingsDirectory = getSettingsDirectoryFile();

		if (!projectDescription.exists() && !classpathFile.exists() && !settingsDirectory.exists()) {
			return true;
		} else if (projectDescription.exists() && classpathFile.exists() && settingsDirectory.exists()) {
			return false;
		} else {
			String loggerInfo;

			if (projectDescription.exists()) {
				moveFile(projectDescription, getProjectDescriptionRenameFile());
				existingProjectFileMoved = true;

				loggerInfo = NLS.bind(Messages.StandaloneConfig_fileBackupDone, PROJECT_FILE_NAME);
				logger.debug(loggerInfo);
			}

			if (classpathFile.exists()) {
				moveFile(classpathFile, getClasspathFileRenameFile());
				existingClasspathFileMoved = true;

				loggerInfo = NLS.bind(Messages.StandaloneConfig_fileBackupDone, CLASSPATH_FILE_NAME);
				logger.debug(loggerInfo);
			}

			if (settingsDirectory.exists()) {
				moveFile(settingsDirectory, getSettingsDirectoryRenameFile());
				existingSettingsDirectoryMoved = true;

				loggerInfo = NLS.bind(Messages.StandaloneConfig_directoryBackupDone, SETTINGS_DIRECTORY_NAME);
				logger.debug(loggerInfo);
			}

			return true;
		}

	}

	/**
	 * this method creates and opens a new {@link IProject}
	 * 
	 * @param description
	 *            project description of the new project
	 * @return a newly created and opened project
	 * @throws CoreException
	 */
	IProject initProject(IProjectDescription description) throws CoreException {
		IWorkspace workspace = getWorkspace();

		IProject project = getProject(workspace, description.getName());
		project.create(description, new NullProgressMonitor());

		String loggerInfo = NLS.bind(Messages.StandaloneConfig_debug_createProject, description.getName());
		logger.debug(loggerInfo);

		project.open(new NullProgressMonitor());

		logger.debug(Messages.StandaloneConfig_debug_createdProject);

		return project;
	}

	/**
	 * takes an {@link IProject} and converts it in a java project of type
	 * {@link IJavaProject}. The java version is set here.
	 * 
	 * @param project
	 *            project to convert in a java project
	 * @return a java project
	 * @throws JavaModelException
	 */
	IJavaProject initJavaProject(IProject project) throws JavaModelException {
		logger.debug(Messages.StandaloneConfig_debug_createJavaProject);

		javaProject = createJavaProject(project);

		// set compiler compliance level from the project
		javaProject.setOption(JavaCore.COMPILER_COMPLIANCE, compilerCompliance);
		javaProject.setOption(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, compilerCompliance);
		javaProject.setOption(JavaCore.COMPILER_SOURCE, compilerCompliance);

		String loggerInfo = NLS.bind(Messages.StandaloneConfig_CompilerComplianceSetTo, compilerCompliance);
		logger.debug(loggerInfo);

		javaProject.open(new NullProgressMonitor());

		return javaProject;
	}

	/**
	 * this method gets all {@link ICompilationUnit}s from the project and
	 * returns them.
	 * 
	 * @return list of {@link ICompilationUnit}s on project
	 * @throws JavaModelException
	 */
	List<ICompilationUnit> getCompilationUnits() throws JavaModelException {
		List<ICompilationUnit> units = new ArrayList<>();

		logger.debug(Messages.StandaloneConfig_collectCompilationUnits);
		List<IPackageFragment> packages = Arrays.asList(javaProject.getPackageFragments());
		for (IPackageFragment mypackage : packages) {
			if (mypackage.containsJavaResources() && 0 != mypackage.getCompilationUnits().length) {
				mypackage.open(new NullProgressMonitor());

				units.addAll(Arrays.asList(mypackage.getCompilationUnits()));
			}
		}
		return units;
	}

	/**
	 * Collects all jars from tmp folder in which maven plugin copied
	 * dependencies. Creates {@link IClasspathEntry} for each jar and returns
	 * them.
	 */
	List<IClasspathEntry> collectMavenDependenciesAsClasspathEntries() {
		logger.debug(Messages.StandaloneConfig_debug_collectDependencies);

		List<IClasspathEntry> collectedEntries = new ArrayList<>();

		File depsFolder = getMavenDependencyFolder();
		File[] listOfFiles = depsFolder.listFiles();

		if (null != listOfFiles) {
			logger.debug(Messages.StandaloneConfig_CreateClasspathEntriesForDependencies);
			for (File file : listOfFiles) {
				String jarPath = file.toString();
				IClasspathEntry jarEntry = createLibraryClasspathEntry(jarPath);
				collectedEntries.add(jarEntry);
			}
		}

		return collectedEntries;
	}

	/**
	 * Adds all classpath entries on classpath of received java project
	 * 
	 * @param javaProject
	 *            project to which classpath entries should be added
	 * @param classpathEntries
	 *            new entries to be added to classpath
	 * @throws JavaModelException
	 */
	void addToClasspath(List<IClasspathEntry> classpathEntries) throws JavaModelException {

		logger.debug(Messages.StandaloneConfig_ConfigureClasspath);

		if (!classpathEntries.isEmpty()) {
			oldEntries = javaProject.getRawClasspath();
			IClasspathEntry[] newEntries;

			if (oldEntries.length != 0) {
				Set<IClasspathEntry> set = new HashSet<>(Arrays.asList(oldEntries));
				set.addAll(classpathEntries);
				newEntries = set.toArray(new IClasspathEntry[set.size()]);
			} else {
				newEntries = classpathEntries.toArray(new IClasspathEntry[classpathEntries.size()]);
			}

			javaProject.setRawClasspath(newEntries, null);
		}
	}

	/**
	 * On stop, checks if the maven eclipse plugin's eclipse goal has been used
	 * to generate a temporary eclipse project and reverts it by using the
	 * eclipse maven plugin's clean goal.
	 * 
	 * @throws JavaModelException
	 * @throws IOException
	 * @throws MavenInvocationException
	 */
	public void cleanUp() throws JavaModelException, MavenInvocationException, IOException {
		if (!cleanUpAlreadyDone) {
			logger.debug(Messages.StandaloneConfig_debug_cleanUp);
			if (descriptionGenerated) {
				mavenInovker.invoke(ECLIPSE_MAVEN_NAME, ECLIPSE_CLEAN_GOAL, null);

				String loggerInfo;

				if (existingProjectFileMoved) {
					Files.move(getProjectDescriptionRenameFile().toPath(), getProjectDescriptionFile().toPath());
					loggerInfo = NLS.bind(Messages.StandaloneConfig_fileRestoreDone, PROJECT_FILE_NAME);
					logger.debug(loggerInfo);
				}

				if (existingClasspathFileMoved) {
					Files.move(getClasspathFileRenameFile().toPath(), getClasspathFileFile().toPath());
					loggerInfo = NLS.bind(Messages.StandaloneConfig_fileRestoreDone, CLASSPATH_FILE_NAME);
					logger.debug(loggerInfo);
				}

				if (existingSettingsDirectoryMoved) {
					Files.move(getSettingsDirectoryRenameFile().toPath(), getSettingsDirectoryFile().toPath());
					loggerInfo = NLS.bind(Messages.StandaloneConfig_directoryRestoreDone, SETTINGS_DIRECTORY_NAME);
					logger.debug(loggerInfo);
				}
			} else {
				revertClasspath();
			}
			cleanUpAlreadyDone = true;
		}
	}

	private void revertClasspath() throws JavaModelException {
		logger.debug(Messages.StandaloneConfig_RevertClasspath);
		if (null != oldEntries) {
			javaProject.setRawClasspath(oldEntries, null);
		}
	}

	/*** HELPER METHODS ***/

	protected IWorkspace getWorkspace() {
		IWorkspace workspace = ResourcesPlugin.getWorkspace();

		String loggerInfo = NLS.bind(Messages.StandaloneConfig_debug_createWorkspace, workspace.getRoot()
			.getLocation()
			.toString());
		logger.debug(loggerInfo);

		return workspace;
	}

	protected File getProjectDescriptionFile() {
		return new File(path + File.separator + PROJECT_FILE_NAME);
	}

	protected File getProjectDescriptionRenameFile() {
		return new File(path + File.separator + PROJECT_FILE_NAME + TEMP_FILE_EXTENSION);
	}

	protected File getClasspathFileRenameFile() {
		return new File(path + File.separator + CLASSPATH_FILE_NAME + TEMP_FILE_EXTENSION);
	}

	protected File getClasspathFileFile() {
		return new File(path + File.separator + CLASSPATH_FILE_NAME);
	}

	protected File getSettingsDirectoryRenameFile() {
		return new File(path + File.separator + SETTINGS_DIRECTORY_NAME + TEMP_FILE_EXTENSION);
	}

	protected File getSettingsDirectoryFile() {
		return new File(path + File.separator + SETTINGS_DIRECTORY_NAME);
	}

	protected String getPomFilePath() {
		return path + File.separator + "pom.xml"; //$NON-NLS-1$
	}

	protected IProject getProject(IWorkspace workspace, String name) {
		return workspace.getRoot()
			.getProject(name);
	}

	protected IJavaProject createJavaProject(IProject project) {
		return JavaCore.create(project);
	}

	protected File getMavenDependencyFolder() {
		return new File(
				System.getProperty(RefactoringInvoker.USER_DIR) + File.separator + RefactoringInvoker.DEPENDENCIES_FOLDER_CONSTANT);
	}

	protected IClasspathEntry createLibraryClasspathEntry(String jarPath) {
		return JavaCore.newLibraryEntry(new Path(jarPath), null, null);
	}

	/**
	 * Getter for IJavaProject
	 * 
	 * @return generated IJavaProject
	 */
	public IJavaProject getJavaProject() {
		return javaProject;
	}

	protected void setJavaProject(IJavaProject javaProject) {
		this.javaProject = javaProject;
	}

	protected boolean isDescriptionGenerated() {
		return descriptionGenerated;
	}

	protected MavenInvoker getMavenInvoker() {
		File mavenHomeFile = new File(this.mavenHome);
		File pomFile = new File(getPomFilePath());
		return new MavenInvoker(mavenHomeFile, pomFile);
	}

	/**
	 * Getter method for list of {@link ICompilationUnit}s collected from the
	 * project.
	 * 
	 * @return list of {@link ICompilationUnit}s collected from the project
	 */
	public List<ICompilationUnit> getCompUnits() {
		return compUnits;
	}

	protected void moveFile(File src, File dest) throws IOException {
		Files.move(src.toPath(), dest.toPath());
	}

	protected boolean isExistingProjectFileMoved() {
		return existingProjectFileMoved;
	}

	protected boolean isExistingClasspathFileMoved() {
		return existingClasspathFileMoved;
	}

	protected boolean isExistingSettingsDirectoryMoved() {
		return existingSettingsDirectoryMoved;
	}

}

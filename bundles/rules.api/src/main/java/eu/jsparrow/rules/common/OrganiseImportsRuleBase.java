package eu.jsparrow.rules.common;

import java.time.Duration;
import java.util.Arrays;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jface.text.Document;
import org.eclipse.ltk.core.refactoring.DocumentChange;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.TextEdit;

import eu.jsparrow.i18n.Messages;
import eu.jsparrow.rules.common.statistics.FileChangeCount;
import eu.jsparrow.rules.common.statistics.RuleApplicationCount;
import eu.jsparrow.rules.common.util.RefactoringUtil;
import eu.jsparrow.rules.common.visitor.AbstractASTRewriteASTVisitor;

/**
 * Organise imports in a Java class, the rule does not use an
 * {@link AbstractASTRewriteASTVisitor} so the abstract class itself can be
 * passed to the constructor. <br>
 * The warning concerning restrictions is generated by a call to
 * {@link OrganizeImportsOperation}, which is an internal Eclipse class
 * 
 * @author Hannes Schweighofer, Ludwig Werzowa, Matthias Webhofer
 * @since 0.9.2
 *
 */

public abstract class OrganiseImportsRuleBase extends RefactoringRuleImpl<AbstractASTRewriteASTVisitor> {

	public static final String ORGANISE_IMPORTS_RULE_ID = "OrganizeImports"; //$NON-NLS-1$

	public OrganiseImportsRuleBase() {
		super();
		this.visitorClass = AbstractASTRewriteASTVisitor.class;
		this.id = ORGANISE_IMPORTS_RULE_ID;
		this.ruleDescription = new RuleDescription(Messages.OrganiseImportsRule_name,
				Messages.OrganiseImportsRule_description, Duration.ofMinutes(1),
				Arrays.asList(Tag.JAVA_1_1, Tag.FORMATTING, Tag.READABILITY, Tag.FREE));
	}

	@Override
	protected String provideRequiredJavaVersion() {
		return JavaCore.VERSION_1_1;
	}

	@Override
	protected DocumentChange applyRuleImpl(ICompilationUnit workingCopy, CompilationUnit astRoot)
			throws ReflectiveOperationException, JavaModelException {

		try {
			return applyOrganising(workingCopy);
		} catch (CoreException e) {
			throw new JavaModelException(e);
		}
	}

	private DocumentChange applyOrganising(ICompilationUnit workingCopy) throws CoreException {

		final CompilationUnit astRoot = RefactoringUtil.parse(workingCopy);
		final boolean[] hasAmbiguity = new boolean[] { false };

		TextEdit edit = createTextEdits(workingCopy, astRoot, hasAmbiguity);

		DocumentChange documentChange = null;

		if (edit != null && !(edit instanceof MultiTextEdit && edit.getChildrenSize() == 0)) {
			FileChangeCount count = RuleApplicationCount.getFor(this)
				.getApplicationsForFile(workingCopy.getHandleIdentifier());
			count.clear();
			count.update();
			Document document = new Document(workingCopy.getSource());
			documentChange = createDocumentChange(edit, document);

			workingCopy.applyTextEdit(edit, null);

		}

		return documentChange;
	}

	protected abstract DocumentChange createDocumentChange(TextEdit edit, Document document);

	protected abstract TextEdit createTextEdits(ICompilationUnit workingCopy, final CompilationUnit astRoot,
			final boolean[] hasAmbiguity) throws CoreException;
}
